pipeline {
  agent any

  parameters {
    choice(
      name: 'ACTION',
      choices: ['apply', 'destroy'],
      description: 'Terraform Action'
    )
    booleanParam(
      name: 'SONARQUBE_ENABLED',
      defaultValue: false,
      description: 'Run SonarQube analysis (requires sonar-project.properties)'
    )
  }

  environment {
    AWS_DEFAULT_REGION = 'us-east-1'
    CLUSTER_NAME       = 'nti-nonprod-eks'

    TF_STATE_BUCKET = 'nti-terraform-states-1'
    TF_STATE_KEY    = 'eks/nonprod/terraform.tfstate'

    // مسار kubeconfig داخل الـ workspace
    KUBECONFIG_PATH = "${env.WORKSPACE}/kubeconfig"

    // إعدادات SonarQube (لا تغيّر باقي البايبلاين)
    SONARQUBE_SERVER = 'SonarServer'   // اسم السيرفر المعرّف في Jenkins
    SONAR_SCANNER    = 'SonarScanner'  // اسم الأداة المعرّفة في Jenkins Tools
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    // ===================== SonarQube (اختياري) =====================
    stage('SonarQube Scan') {
      when {
        allOf {
          expression { return params.SONARQUBE_ENABLED }
          expression { return fileExists('sonar-project.properties') }
        }
      }
      steps {
        script {
          echo "SonarQube is enabled and sonar-project.properties found. Running analysis…"
        }
        withSonarQubeEnv("${SONARQUBE_SERVER}") {
          withEnv(["PATH+SONAR=${tool "${SONAR_SCANNER}"}/bin"]) {
            sh '''
              set -euxo pipefail
              sonar-scanner
            '''
          }
        }
      }
    }

    stage('Quality Gate') {
      when {
        allOf {
          expression { return params.SONARQUBE_ENABLED }
          expression { return fileExists('sonar-project.properties') }
        }
      }
      steps {
        script {
          // يفضّل تكوين Webhook من SonarQube إلى Jenkins لسرعة الرد
          timeout(time: 5, unit: 'MINUTES') {
            def qg = waitForQualityGate() // سيفشل الستيج لو الحالة FAILED
            echo "Quality Gate status: ${qg.status}"
          }
        }
      }
    }
    // ===============================================================

    stage('Terraform Init') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail

              terraform init -reconfigure \
                -backend-config="bucket=${TF_STATE_BUCKET}" \
                -backend-config="key=${TF_STATE_KEY}" \
                -backend-config="region=${AWS_DEFAULT_REGION}"
            '''
          }
        }
      }
    }

    stage('Terraform Plan') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail
              terraform plan -out=tfplan
            '''
          }
        }
      }
    }

    stage('Terraform Apply') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail
              terraform apply -auto-approve tfplan
            '''
          }
        }
      }
    }

    stage('Configure kubeconfig') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            aws eks update-kubeconfig \
              --region "${AWS_DEFAULT_REGION}" \
              --name "${CLUSTER_NAME}" \
              --kubeconfig "${KUBECONFIG_PATH}"

            # عرض نسخ العميل والخادم بدون --short (توافق أعلى)
            kubectl --kubeconfig "${KUBECONFIG_PATH}" version -o json | jq -r '.clientVersion.gitVersion, .serverVersion.gitVersion' || true
            kubectl --kubeconfig "${KUBECONFIG_PATH}" get --raw /version | jq || true
          '''
        }
      }
    }

    stage('Preflight (Cluster Access)') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            aws sts get-caller-identity
            kubectl --kubeconfig "${KUBECONFIG_PATH}" cluster-info
            kubectl --kubeconfig "${KUBECONFIG_PATH}" get --raw /openapi/v2 | head -n 1
            kubectl --kubeconfig "${KUBECONFIG_PATH}" auth can-i create namespace
            kubectl --kubeconfig "${KUBECONFIG_PATH}" get nodes
          '''
        }
      }
    }

    stage('Install Argo CD (Helm)') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            kubectl --kubeconfig "${KUBECONFIG_PATH}" create namespace argocd --dry-run=client -o yaml | \
              kubectl --kubeconfig "${KUBECONFIG_PATH}" apply -f -

            helm repo add argo https://argoproj.github.io/argo-helm || true
            helm repo update

            helm upgrade --install argocd argo/argo-cd \
              --namespace argocd \
              --create-namespace \
              --wait \
              --kubeconfig "${KUBECONFIG_PATH}"

            kubectl --kubeconfig "${KUBECONFIG_PATH}" -n argocd get pods
          '''
        }
      }
    }

    stage('Uninstall Argo CD (before destroy)') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            aws eks update-kubeconfig \
              --region "${AWS_DEFAULT_REGION}" \
              --name "${CLUSTER_NAME}" \
              --kubeconfig "${KUBECONFIG_PATH}"

            helm uninstall argocd -n argocd --kubeconfig "${KUBECONFIG_PATH}" || true
            kubectl --kubeconfig "${KUBECONFIG_PATH}" delete namespace argocd --wait=false || true
          '''
        }
      }
    }

    stage('Terraform Destroy') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail
              terraform destroy -auto-approve
            '''
          }
        }
      }
    }
  }

  post {
    always {
      script {
        try {
          archiveArtifacts artifacts: 'Ingress/tfplan', allowEmptyArchive: true
        } catch (err) {
          echo "No plan file to archive."
        }
      }
    }
    failure {
      echo 'Pipeline failed. Check logs above for details.'
    }
    success {
      echo 'Pipeline finished successfully.'
    }
  }
}
