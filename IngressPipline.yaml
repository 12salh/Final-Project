pipeline {
  agent any

  parameters {
    choice(
      name: 'ACTION',
      choices: ['apply', 'destroy'],
      description: 'Terraform Action'
    )
  }

  environment {
    AWS_DEFAULT_REGION = 'us-east-1'
    CLUSTER_NAME       = 'nti-nonprod-eks'

    TF_STATE_BUCKET = 'nti-terraform-states-1'
    TF_STATE_KEY    = 'eks/nonprod/terraform.tfstate'

    // نحفظ kubeconfig داخل الـ workspace ونستخدمه صراحة في كل الأوامر
    KUBECONFIG_PATH = "${env.WORKSPACE}/kubeconfig"

    // (اختياري) لو عندك بروكسي، فعل السطور دي واضبط NO_PROXY:
    // HTTP_PROXY  = 'http://proxy.example:8080'
    // HTTPS_PROXY = 'http://proxy.example:8080'
    // NO_PROXY    = '127.0.0.1,localhost,svc,.svc,cluster.local,.cluster.local,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,gr7.us-east-1.eks.amazonaws.com'
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Terraform Init') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail

              terraform init -reconfigure \
                -backend-config="bucket=${TF_STATE_BUCKET}" \
                -backend-config="key=${TF_STATE_KEY}" \
                -backend-config="region=${AWS_DEFAULT_REGION}"
            '''
          }
        }
      }
    }

    stage('Terraform Plan') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail
              terraform plan -out=tfplan
            '''
          }
        }
      }
    }

    stage('Terraform Apply') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail
              terraform apply -auto-approve tfplan
            '''
          }
        }
      }
    }

    stage('Configure kubeconfig') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            # نولد/نحدّث kubeconfig في مسار معروف
            aws eks update-kubeconfig \
              --region "${AWS_DEFAULT_REGION}" \
              --name "${CLUSTER_NAME}" \
              --kubeconfig "${KUBECONFIG_PATH}"

            # اطبع نسخ العميل/الخادم بصيغ متوافقة (بدون --short)
            kubectl --kubeconfig "${KUBECONFIG_PATH}" version -o json | jq -r '.clientVersion.gitVersion, .serverVersion.gitVersion' || true
            kubectl --kubeconfig "${KUBECONFIG_PATH}" get --raw /version | jq || true
          '''
        }
      }
    }

    stage('Preflight (Cluster Access)') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            # تأكد من هوية AWS (مهم لنجاح exec auth)
            aws sts get-caller-identity

            # تأكد من الوصول للكلاستر وقراءة مخطط OpenAPI وصلاحيات إنشاء namespace
            kubectl --kubeconfig "${KUBECONFIG_PATH}" cluster-info
            kubectl --kubeconfig "${KUBECONFIG_PATH}" get --raw /openapi/v2 | head -n 1
            kubectl --kubeconfig "${KUBECONFIG_PATH}" auth can-i create namespace
            kubectl --kubeconfig "${KUBECONFIG_PATH}" get nodes
          '''
        }
      }
    }

    stage('Install Argo CD (Helm)') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            # إنشاء/تأكيد namespace
            kubectl --kubeconfig "${KUBECONFIG_PATH}" create namespace argocd --dry-run=client -o yaml | \
              kubectl --kubeconfig "${KUBECONFIG_PATH}" apply -f -

            # إضافة وتحديث مستودع Helm
            helm repo add argo https://argoproj.github.io/argo-helm
            helm repo update

            # تثبيت/تحديث Argo CD
            helm upgrade --install argocd argo/argo-cd \
              --namespace argocd \
              --create-namespace \
              --wait \
              --kubeconfig "${KUBECONFIG_PATH}"

            # تأكيد التشغيل
            kubectl --kubeconfig "${KUBECONFIG_PATH}" -n argocd get pods
          '''
        }
      }
    }

    stage('Uninstall Argo CD (before destroy)') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          sh '''
            set -euxo pipefail

            # نضمن kubeconfig صالح في حالة تشغيل destroy منفردًا
            aws eks update-kubeconfig \
              --region "${AWS_DEFAULT_REGION}" \
              --name "${CLUSTER_NAME}" \
              --kubeconfig "${KUBECONFIG_PATH}"

            helm uninstall argocd -n argocd --kubeconfig "${KUBECONFIG_PATH}" || true
            kubectl --kubeconfig "${KUBECONFIG_PATH}" delete namespace argocd --wait=false || true
          '''
        }
      }
    }

    stage('Terraform Destroy') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_cred']]) {
          dir('Ingress') {
            sh '''
              set -euxo pipefail
              terraform destroy -auto-approve
            '''
          }
        }
      }
    }
  }

  post {
    always {
      // (اختياري) أرشف ملفات التخطيط/اللوج
      script {
        try {
          archiveArtifacts artifacts: 'Ingress/tfplan', allowEmptyArchive: true
        } catch (err) {
          echo "No plan file to archive."
        }
      }
    }
    failure {
      echo 'Pipeline failed. Check logs above for details.'
    }
    success {
      echo 'Pipeline finished successfully.'
    }
  }
}
